---
layout: post
title: "HAZEL学习笔记_添加事件"
categories: Algorithm
---

## Hazel 添加事件
### 1.基础知识学习
bind和function[https://www.jianshu.com/p/f191e88dcc80]  

先来学习下
可调用对象有以下几种形式
1.是一个函数指针
2.是一个具有operator()成员的函数的类的对象
3.可被转换成函数指针的类对象
4.一个类成员函数指针
不同类型可能具有相同的调用形式
```c++
#include<iostream>
#include <utility>
#include <algorithm>
#include <functional>

float add(float a, float b) { return a + b; }
auto lambdaAdd = [](float a, float b) {return a + b; };
struct structAdd {
	float operator()(float a, float b) {
		return a + b;
	}
};


void main() {

	std::cout << "result " << add(1, 2) << std::endl;
	std::cout << "result " << lambdaAdd(1, 2) << std::endl;
	structAdd structadd;
	std::cout << "result " << structadd(1.0, 2.0) << std::endl;
	auto floatAdd = BIND_FUNCTION_FN(add);
//采用function绑定调用方式相同的函数  int(int,int)
	std::function<int(int, int)> a = add;
	std::function<int(int, int)> b = lambdaAdd;
	std::function<int(int, int)> c = structadd;

	std::cout << "function result " << a(1, 2) << std::endl;
	std::cout << "function result " << b(1, 2) << std::endl;
	std::cout << "function result " << c(1, 2) << std::endl;
	std::cout << "result " << floatAdd(1, 2) << std::endl;
}

```
std::bind，可看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来"适应"原对象的参数列表。
std::bind将可调用对象与其参数一起进行绑定，绑定的结果可以使用std::function保存，
std::bind主要有以下两个作用
* 将可调用对象和其参数绑定成一个仿函数
* 只绑定部分参数，减少可调用对象传入的参数
```c++
//std::bind 绑定普通函数
double my_divide (double x, double y) {return x/y;}
auto fn_half = std::bind (my_divide,_1,2);  
std::cout << fn_half(10) << '\n';    
//std::bind 绑定一个成员函数
struct Foo {
    void print_sum(int n1, int n2)
    {
        std::cout << n1+n2 << '\n';
    }
    int data = 10;
};
int main() 
{
    Foo foo;
    auto f = std::bind(&Foo::print_sum, &foo, 95, std::placeholders::_1);
    f(5); // 100
}
```

### 2.窗体事件的绑定和实际的使用
参考glfw中相关对象的使用
https://www.glfw.org/docs/latest/quick_guide.html#quick_steps

```c++
// Application.cpp和onEvent绑定
Application::Application()
	{
		m_Window = std::unique_ptr<Window>(Window::Create());
		m_Window->SetEventCallback(BIND_EVENT_FN(onEvent));
	}

//对消息进行分发和响应
void Application::onEvent(Event& e)
	{
		EventDispatcher dispatcher(e);
		dispatcher.Dispatch<WindowCloseEvent>(BIND_EVENT_FN(OnWindowClose));
		HZ_CORE_TRACE("{0}", e);
	}
//Run函数调用OnUpdate()函数
void Application::Run()
	{
		while (m_Running)
		{
			glClearColor(1, 0, 1, 1);
			glClear(GL_COLOR_BUFFER_BIT);
			m_Window->OnUpdate();
		}
	}

//	void WindowsWindow::OnUpdate()
	{
		glfwPollEvents();//对事件进行轮询
		glfwSwapBuffers(m_Window);//
	}	
```
